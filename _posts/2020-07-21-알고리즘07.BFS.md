---
layout: post
title: 자료구조 & 알고리즘 12. BFS
modified: 2020-07-21
author: Yo0oN
categories: 자료구조&알고리즘
tags: [알고리즘]
comments: true
published : true
---

* Table of Contents
{:toc}

<br>

## 1. BFS 너비 우선 탐색

BFS(Breadth-First Search)는 너비 우선 탐색으로, 그래프 알고리즘 중 하나이다.

<center><img src="/images/posts/Algorithm/07.BFS&DFS/01.jpg" /></center>

임의의 노드 하나를 기준으로 잡은 후 해당 노드에서부터 가까이 있는 노드들을 순서로 방문하는 방식으로 탐색을 진행한다.

위의 그림을 보면, 노드 A를 기준으로 해당 노드와 가장 가까운, 간선 하나만으로 이동할 수 있는 B, C를 먼저 탐색한 후, 간선 두개로 이동할 수 있는 D, G, H, I를 탐색하고 있다.

BFS는 두 노드 사이의 최단 경로나, 임의의 경로를 찾고 싶을 때 사용하면 좋다.

<br>

BFS는  시간 복잡도는 $$O(V+E)$$로 표현되며, V는 노드, E는 간선이다.

<br>

<hr>

<br>

## 2. 구현하기

BFS는 가장 가까이 있는것부터 순서 상관없이 탐색하기 때문에, 구현 할 때는 어떤 노드를 방문했는지 기억하고 있는 리스트 하나와, 방문한 노드의 인접 노드들이며, 앞으로 방문해야 할 노드가 적혀있는 큐를 이용해야 한다.

1. 일단 노드 하나를 기준으로 잡은 후, 큐에 해당 노드를 넣는다.
2. 링크드리스트, 맵, 딕셔너리 등등 값을 저장할 수 있는 자료구조를 하나 선택하여, 키나 인덱스는 하나의 노드, 값은 인접한 노드의 배열을 담는다.
3. 첫번째 노드를 하나 탐색한 후 노드에 넣는다.
4. 탐색한 노드가 키(또는 인덱스)로 있는 값들의 노드들을 큐에 넣고, 앞에서 부터 하나씩 추출하면 탐색한다.
5. 탐색을 하면서, 탐색한 순서가 적힌 리스트에서 이미 다녀온 노드인지 비교하는 작업을 해야한다.
5. 4번과 5번을 반복한다.

```python
def bfs(graph, start_node) :
	visited = list() # 방문할 순서가 적히는 visited
	queue = list() # 	방문해야할 노드들이 적혀있는 대기공간 queue

	queue.append(start_node) # 처음 기준 노드를 큐에 넣는다.

	while queue :
		node = queue.pop(0) # 큐의 제일 앞에 있는 노드를 추출한다.
		if node not in visit : # 만약 방문하지 않은 노드라면
			visit.append(node) # 방문을하고,
			queue.extend(graph[node]) # 방문한 노드의 인접 노드들을 대기 공간인 큐에 넣어준다.

	return visit
```
