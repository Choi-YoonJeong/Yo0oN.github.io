---
layout: post
title: 자료구조 & 알고리즘 11. 트리
modified: 2020-07-18
author: Yo0oN
categories: 자료구조&알고리즘
tags: [자료구조]
comments: true
published : true
---

* Table of Contents
{:toc}

<br>

## 1. 트리

<center><img src="/images/posts/DataStructure/05.Tree/01.png" width="80%" /></center>

노드를 이용하여 정보를 저장하며, 노드끼리 사이클을 이루지 않는 구조이다.<br>
위의 그림처럼 루트노드부터 가지가 뻗어나와 다른 노드들이 붙어있는 모습이 나무를 닮았다고 하여 트리라고 불린다.<br>
유닉스, 리눅스의 디렉터리 구조도 트리구조이다.

<center><img src="/images/posts/DataStructure/05.Tree/04.jpg" width="80%" /></center>

추가적으로 사이클은, 여러 노드와 노드가 이어져있을 때, 간선을 따라 가다보면 처음 정점을 다시 만나는 구조로 처음 정점과, 끝 정점이 같은 경우를 말한다.<br>
하지만 트리는 부모 -> 자식 노드로만 이어져 있기 때문에 처음 정점이 끝 정점이 되는 일은 없기 때문에 사이클을 이루지 않는 구조라 한것이다.

<hr>

### 1-1. 용어

<br>
<center><img src="/images/posts/DataStructure/05.Tree/02.jpg" width="80%" /></center>

- Node(=vertex정점) : 트리에서 데이터를 저장하는 기본 요소. 노드 = 데이터 + 다음 노드의 주소
- Eage(간선) : 노드를 연결하는 선
- Root Node : 트리의 가장 위에 있는 노드
- Leaf Node : 가지의 가장 아래쪽, 즉 자식이 없는 노드
- Level : 루트노드를 0으로 하여 야래쪽의 노드 중 가지를 쳐서 연결된 노드들의 깊이
- Parent Node : 아래로 가지를 뻗어 자식 노드를 가지고 있는 노드
- Child Node : 위에서 가지가 이어져나와 이어져있는 노드
- Depth : 트리에서 노드가 가질 수 있는 최대 레벨

<br>

<br>

<hr>

## 2. 트리와 그래프

트리와 그래프는 둘다 노드와 간선이 있다는 점에서 비슷하게 생겼지만, 트리는 그래프의 한 종류일 뿐이다.<br>

<table>
  <tr>
    <th></th>
    <th>그래프</th>
    <th>트리</th>
   </tr>
  <tr>
    <td>정의</td>
    <td>노드와 노드를 연결하는 간선으로 표현되는 자료구조</td>
    <td>방향성이 있는 비순환 그래프</td>
   </tr>
   <tr>
    <td>종류</td>
    <td>방향그래프, 무방향그래프, 비연결그래프...</td>
    <td>방향그래프</td>
   </tr>
   <tr>
    <td>사이클</td>
    <td>사이클이 가능하다.</td>
    <td>사이클이 없다.</td>
   </tr>
   <tr>
    <td>루트노드</td>
    <td>루트노드가 없다.</td>
    <td>루트노드가 있다.</td>
   </tr>
   <tr>
    <td>부모&자식</td>
    <td>부모와 자식의 개념이 없다.</td>
    <td>부모와 자식의 개념이 있다.</td>
   </tr>
</table>

<br>

<br>

<hr>

## 3. 이진트리 & 이진탐색트리

<center><img src="/images/posts/DataStructure/05.Tree/05.jpg" width="80%" /></center>

이진트리는 노드 하나 당 아래로 뻗어나온 가지가 최대 두개까지 있는 트리를 말한다.

이진탐색트리(BST Binary Search Tree)는 이진 트리에서 현재 노드보다 작은 값은 왼쪽, 큰 값은 오른쪽 노드로 가는 조건이 있는 트리이다.<br>
이진탐색트리를 이용하면 값이 이미 정렬되어있기 떄문에 빠르게 원하는 값을 탐색할 수 있다는 장점이 있다.

<br>

<hr>

<br>

## 4. 이진탐색트리 구현하기

### 4-1. 준비

```python
class Node :
  def __init__(self, data) :
    self.data = data
    self.left = None
    self.right = None

class BinarySearchTree :
  def __init__(self, data) :
    self.root = Node(data) # 루트노드에 값을 하나 넣는다.
```
<br>

### 4-2. 이진탐색트리에 값 삽입하는 메서드

```python
  def insert(self, data) :
    self.current_node = self.root
    while True :
      # 현재 넣으려는 값이 루트값보다 작을경우 왼쪽으로
      if data < self.current_node.data :
        # 왼쪽노드가 있다면 계속 탐색
        if self.current_node.left != None :
          self.current_node = self.current_node.left
        else : # 없다면 그자리에 값 넣기
          self.current_node.left = Node(data)
          break
      else : # 현재 넣으려는 값이 루트값보다 클경우 오른쪽으로
        if self.current_node.right != None :
          self.current_node = self.current_node.right
        else :
          self.current_node.right = Node(data)
          break
```
<br>

### 4-3. 이진탐색트리에서 값이 있는지 찾기

```python
  def search(self, data) :
    self.current_node = self.root
    while self.current_node :
      if self.current_node.data == data :
        return True
      elif data < self.current_node.data :
        self.current_node = self.current_node.left
      else :
        self.current_node = self.current_node.right
    return False
```
<br>

### 4-4. 이진트리에서 값 삭제하기

삭제하는 노드가 리프노드라면 다행이지만, 아래에 자식이 있는 부모노드라면 빈자리를 다른 노드가 채워주어야 한다.<br>
경우의 수를 잘 생각해보자.<br>

  1. 자식노드가 없는경우

  2. 삭제하려는 노드의 왼쪽 또는 오른쪽에만 자식이 있을 경우<br>
     삭제할 노드의 왼쪽 또는 오른쪽 자식과 부모를 이어주면 된다.
   
  3. 삭제하려는 노드의 양쪽에 자식이 있을 경우<br>
     이런경우 2가지 방법이 있다.<br>
    3-1. 삭제하려는 노드의 오른쪽 자식 중 가장 작은 자식을 가져와 빈자리에 넣는다.<br>
    3-2. 삭제하려는 노드의 왼쪽 자식 중 가장 큰 자식을 가져와 빈자리에 넣는다.<br>
     하지만 이련경우 가져온 자식에게도 또다른 자식이 있으면 그부분도 처리를 해줘야 한다.
   
위의 3번을 보면 삭제하려는 노드의 오른쪽 또는 왼쪽 자식 중 가장 작은 자식 또는 가장 큰 자식을 가져와 빈자리에 넣는다고 되어있는데, 그 이유는 아래의 그림을 보면 알 수 있다.

<center><img src="/images/posts/DataStructure/05.Tree/03.jpg" width="80%" /></center>

3-1. 빈자리를 채우기 위해 아래의 자식들 중 하나를 가져다 써야 하는데 만약 오른쪽 자식 중 하나를 쓴다고 하면, 오른쪽 자식 중 가장 작은값을 빈자리에 넣어야 왼쪽은 부모보다 작고 오른쪽은 부모보다 커야한다는 이진탐색트리의 조건을 만족한다.

3-2 왼쪽자식에서 가져다 쓰는 경우도 마찬가지다.

```python
  def delete(self, data) :
    # 삭제할 노드가 있는지 확인하기
    searched = False # 삭제할 값을 찾았는지 여부를 알려주는 searched
    self.current_node = self.root # 현재노드
    self.parent_node = self.root # 부모노드
    while self.current_node : # 현재 노드가 있는 동안 반복
      # 만약 현재 노드가 삭제하려는 값과 같다면 탐색 중지
      if self.current_node.data == data :
        searched = True
        break
      # 만약 현재 노드가 삭제하려는 값보다 크다면 왼쪽 탐색
      elif data < self.current_node.data :
        self.parent_node = self.current_node
        self.current_node = self.current_node.left
      else : # 현재 노드가 삭제하려는 값보다 작다면 오른쪽으로
        self.parent_node = self.current_node
        self.current_node = self.current_node.right
    if searched == False :
      return False

    # 삭제하려는 값을 찾은 경우 이곳으로들어온다.
    # 1. 만약 삭제하려는 노드가 자식이 없는 리프노드라면..
    if self.current_node.left == None and self.current_node.right == None :
      if data < self.parent_node.data : # 현재 값이 부모의 왼쪽노드라면 
        self.parent_node.left = None # 부모의 왼쪽인 나와 연결 끊기
      else : # 부모의 오른쪽 노드라면
        self.parent_node.right = None # 부모의 오른쪽인 나와 연결 끊기

    # 2. 만약 삭제하려는 노드가 자식노드가 있다면...
    # 2-1. 자식노드가 왼쪽만 있다면
    elif self.current_node.left != None and self.current_node.right == None :
      # 나의 부모와 나의 자식을 이어주자.
      if data < self.parent_node.data : # 2-1-1. 내 자식이 왼쪽
        self.parent_node.left = self.current_node.left
      else : # 2-1-2. 내 자식이 오른쪽
        self.parent_node.right = self.current_node.left
    # 2-2. 자식노드가 오른쪽이라면 
    elif self.current_node.left == None and self.current_node.right != None :
      # 나의 부모와 나의 자식을 이어주자.
      if data < self.parent_node.data : # 2-2-1. 내 자식이 왼쪽
        self.parent_node.left = self.current_node.right
      else : # 2-2-2. 내 자식이 오른쪽
        self.parent_node.right = self.current_node.right

    # 3. 삭제하려는 노드가 자식노드가 두개 있다면...
    elif self.current_node.left != None and self.current_node.right != None :
      if data < self.parent_node.data : # 삭제할 노드가 부모의 왼쪽 자식이었다면
        # 3-1. 삭제하려는 노드의 오른쪽 중 가장 작은 값이 현재 자리에 와야함(혹은 왼쪽 중 가장 큰값)
        self.change_node = self.current_node.right # 빈자리를 채워줄 노드
        self.change_node_parent = self.current_node.right # 빈자리를 채우는 노드의 부모 노드
        while self.change_node.left != None : # 삭제노드의 오른쪽 자식을 탐색하여 가장 작은 값을 찾는다.
          self.change_node_parent = self.change_node
          self.change_node = self.change_node.left
        if self.change_node.right != None : # 옮기려는 자식에 오른쪽 자식이 있다면
          self.change_node_parent.left = self.change_node.right # 옮길자식의 부모와 자식을 이어준다.
        else : # 옮기려는 자식에 오른쪽 자식이 없다면(=리프노드)
          self.change_node_parent.left = None
        self.parent_node.left = self.change_node # 빈자리에 바꿀 노드를 넣는다.
        self.change_node.right = self.current_node.right # 바꾼노드의 오른쪽에 기존에 있던 노드들을 이어준다.
        self.change_node.left = self.change_node.left # 바꾼 노드의 왼쪽에 기존에 있던 노드들을 이어준다.
      else : # 삭제할 노드가 부모의 오른쪽 자식이었다면
        self.change_node = self.current_node.right
        self.change_node_parent = self.current_node.right
        while self.change_node.left != None : # 빈자리를 대신할 노드를 찾기
          self.change_node_parent = self.change_node
          self.change_node = self.change_node.left
        if self.change_node.right != None : # 대신할 노드의 오른쪽에 자식이 있다면
          self.change_node_parent.left = self.change_node.right # 빈자리의 부모-빈자리의 오른쪽 연결
        else : # 옮기려는 자식에 오른쪽 자식이 없다면(=리프노드)
          self.change_node_parent.left = None
        self.parent_node.right = self.change_node # 빈자리에 바꿀 노드를 넣는다.
        self.change_node.right = self.current_node.right # 바꾼 노드의 오른쪽에 기존 노드들을 이어준다. 
        self.change_node.left = self.current_node.left# 바꾼 노드의 왼쪽에 기존에 있던 노드들을 이어준다.
    return True
```

나중에 더 간단하게 작성하는 법을 생각해봐야겠다..
