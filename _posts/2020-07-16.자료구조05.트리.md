---
layout: post
title: 자료구조 & 알고리즘 11. 트리
modified: 2020-07-16
author: Yo0oN
categories: 자료구조&알고리즘
tags: [자료구조]
comments: true
published : true
---

* Table of Contents
{:toc}


## 1. 트리


![트리](/images/posts/DataStructure/05.Tree/01.png)

노드를 이용하여 정보를 저장하며, 노드끼리 사이클을 이루지 않는 구조이다.<br>
사이클이 없다는 뜻은, 트리를 보면 부모, 자식 노드는 이어져 있어도 형제 노드 끼리는 이어져 있지 않다.<br>
그렇게 된다면 서로의 관계, 가지가 선일 뿐, 원을 그리지 않는 관계여서 사이클을 이루지 않는 구조라는 뜻이다.

<hr>

### 1-1. 용어

![트리의 용어](/images/posts/DataStructure/05.Tree/02.jpg)

- Node : 트리에서 데이터를 저장하는 기본 요소. 노드 = 데이터 + 다음 노드의 주소
- Root Node : 트리의 가장 위에 있는 노드
- Leaf Node : 가지의 가장 아래쪽, 즉 자식이 없는 노드
- Level : 루트노드를 0으로 하여 야래쪽의 노드 중 가지를 쳐서 연결된 노드들의 깊이
- Parent Node : 아래로 가지를 뻗어 자식 노드를 가지고 있는 노드
- Child Node : 위에서 가지가 이어져나와 이어져있는 노드
- Depth : 트리에서 노드가 가질 수 있는 최대 레벨

<br>

<hr>

<br>

## 2. 트리와 그래프

## 3. 이진트리 & 이진탐색트리

이진트리는 노드 하나 당 아래로 뻗어나온 가지가 최대 두개까지 있는 트리를 말한다.<br>
이진탐색트리는 (BST Binary Search Tree) 이진 트리에서 현재 노드보다 작은 값은 외쪽, 큰 값은 오른쪽 노드로 가는 조건이 있는 트리이다.<br>

이진탐색트리를 이용하면 빠르게 원하는 값을 탐색할 수 있다. 

<br>

<hr>

<br>

### 4. 이진탐색트리 구현하기

```python
class Node :
  def __init__(self, data) :
    self.data = data
    self.left = None
    self.right = None

class BinarySearchTree :
  def __init__(self, data) :
    self.root = Node(data) # 루트노드에 값을 하나 넣는다.

  def insert(self, data) :
    self.current_node = self.root
    while True :
      # 현재 넣으려는 값이 루트값보다 작을경우 왼쪽으로
      if data < self.current_node.data :
        # 왼쪽노드가 있다면 계속 탐색
        if self.current_node.left != None :
          self.current_node = self.current_node.left
        else : # 없다면 그자리에 값 넣기
          self.current_node.left = Node(data)
          break
      else : # 현재 넣으려는 값이 루트값보다 클경우 오른쪽으로
        if self.current_node.right != None :
          self.current_node = self.current_node.right
        else :
          self.current_node.right = Node(data)
          break
```

이진탐색트리에 값 삽입하기

```python
  def search(self, data) :
    self.current_node = self.root
    while self.current_node :
      if self.current_node.data == data :
        return True
      elif data < self.current_node.data :
        self.current_node = self.current_node.left
      else :
        self.current_node = self.current_node.right
    return False
```

이진트리에서 값 삭제하기<br>
이때, 삭제하는 노드가 리프노드라면 다행이지만, 아래에 자식이 있는 부모노드라면 빈자리를 다른 노드가 채워주어야 한다.<br>
경우의 수를 잘 생각해보자.<br>
만약 삭제하려는 노드가 자식이 하나만 있다면, 부모노드와 삭제할 노드의 자식노드를 이어주면 된다.


![트리의 삭제](/images/posts/DataStructure/05.Tree/03.jpg)

하지만 삭제할 노드의 자식이 두개라면 오른쪽 자식 중 가장 작은값 혹은 왼쪽 자식 중 가장 큰 값을 해당 자리에 넣으면 된다.<br>
왜냐하면, 만약 오른쪽 자식 중 하나를 골라다 위로 끌어올리려면, 왼쪽은 부모보다 작고 오른쪽은 부모보다 커야한다는 조건을 만족해야 하므로, 오른쪽 자식 중 가장 작은값(오른쪽 자식 중 가장 왼쪽에 있는값)을 삭제한 노드에 넣어야 한다.<br>
반대의 경우인 왼쪽노드에서 값을 가져오는 것도 마찬가지다.<br>
위의 그림을 보고 천천히 생각해보면 이해가 갈것이다.

``python
  def search(self, data) :
    self.current_node = self.root
    while self.current_node :
      if self.current_node.data == data :
        return True
      elif data < self.current_node.data :
        self.current_node = self.current_node.left
      else :
        self.current_node = self.current_node.right
    return False

    def delete(self, data) :
      # 삭제할 노드가 있는지 확인하기
      searched = False
      self.current_node = self.root
      self.parent_node = self.root
      while self.current_node :
        # 만약 현재 노드가 삭제하려는 값과 같다면 탐색 중지
        if self.current_node.data == data :
          searched = True
          break
        # 만약 현재 노드가 삭제하려는 값보다 크다면 왼쪽으로
        elif data < self.current_node.data :
          self.parent_node = self.current_node
          self.current_node = self.current_node.left
        else : # 현재 노드가 삭제하려는 값보다 작다면 오른쪽으로
          self.parent_node = self.current_node
          self.current_node = self.current_node.right
        
      if !searched : # 삭제하려는 값이 없다면 False 반환, 있다면 아래로.
        return False

      # 1. 만약 삭제하려는 노드가 자식이 없는 리프노드라면..
      if self.current_node.left == None and self.current_node.right == None :
        if data < self.parent_node.data : # 현재 값이 부모의 왼쪽노드라면 
          self.parent_node.left = None # 부모의 왼쪽인 나와 연결 끊기
        else : # 부모의 오른쪽 노드라면
          self.parent_node.rght = None # 부모의 오른쪽인 나와 연결 끊기

      # 2. 만약 삭제하려는 노드가 자식노드가 하나 있다면...
      # 2-1. 자식노드가 왼쪽이라면
      if self.current_node.left != None and self.current_node.right == None :
        # 나의 부모와 나의 자식을 이어주자.
        if data < self.parent_node.data : # 2-1-1. 내 자식이 왼쪽
          self.parent_node.left = self.current_node.left
        else : # 2-1-2. 내 자식이 오른쪽
          self.parent_node.right = self.current_node.left
      # 2-2. 자식노드가 오른쪽이라면 
      elif self.current_node.left == None and self.current_node.right != None :
        # 나의 부모와 나의 자식을 이어주자.
        if data < self.parent_node.data : # 2-1-1. 내 자식이 왼쪽
          self.parent_node.left = self.current_node.right
        else : # 2-1-2. 내 자식이 오른쪽
          self.parent_node.right = self.current_node.right

      # 3. 삭제하려는 노드가 자식노드가 두개 있다면...
      if self.current_node.left != None and self.current_node.right != None :
        # 삭제할 노드가 부모의 왼쪽
        if data < self.parent_node.data :
          # 삭제하려는 노드의 오른쪽 중 가장 작은 값이 현재 자리에 와야함(혹은 왼쪽 중 가장 큰값)
          self.change_node = self.current_node.right
          self.change_node_parent = self.current_node.right
          # 삭제노드의 오른쪽 자식을 탐색하여 가장 작은 값을 찾는다.
          while self.change_node.left != None :
            self.change_node_parent = self.change_node
            self.change_node = self.change_node.left
          if self.change_node.right != None : # 옮기려는 자식에 오른쪽 자식이 없다면 진행(왼쪽은 당연히 없다.)
            self.change_node_parent.left = self.change_node.right
          else : # 옮기려는 자식에 오른쪽 자식이 있다면(자식이 아예 없다.)
            self.change_node_parent.left = None
          self.parent_node.left = self.change_node
          self.change_node.right = self.current_node.right
          self.change_node.left = self.change_node.left
      else :
        self.change_node = self.current_node.right
        self.change_node_parent = self.current_node.right
      while self.change_node.left != None :
        self.change_node_parent = self.change_node
        self.change_node = self.change_node.left
      if self.change_node.right != None :
        self.change_node_parent.left = self.change_node.right
      else :
        self.change_node_parent.left = None
      self.parent.right = self.change_node
      self.change_node.left = self.current_node.left
      self.change_node .right = self.current_node.right
```
